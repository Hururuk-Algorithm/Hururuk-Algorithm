📌 **[ 큐 ]**

: 데이터를 저장하는 자료구조로 먼저 들어간 데이터가 먼저 나오는 형태로 이루어져 있다.

스택과 달리 양쪽(앞, 뒤)에서 접근이 가능하다

: FIFO(first in first out): 먼저 들어간 것이 가장 처음으로 나오는 규칙(= 선입 선출)

📌 **[ 배열과의 차이점 ]**

**큐 vs 배열 비교**

| 특성             | 큐                                  | 배열                             |
| ---------------- | ----------------------------------- | -------------------------------- |
| 접근 방식        | 양쪽 끝(앞/뒤)에서만 접근 가능      | 인덱스로 모든 요소 접근 가능     |
| 데이터 삽입/삭제 | 한쪽에서 삽입, 반대쪽에서 삭제      | 어느 위치에서든 가능             |
| 주요 연산        | enqueue(삽입), dequeue(삭제)        | 조회, 삽입, 삭제, 수정 등 다양함 |
| 사용 원칙        | FIFO (선입선출)                     | 순서에 제한 없음                 |
| 구현 방식        | 배열이나 연결 리스트로 구현 가능    | 메모리에 연속적으로 저장         |
| 주요 용도        | 대기열 관리, 버퍼링, 너비 우선 탐색 | 데이터 저장 및 처리              |

**💬 enqueue: 큐의 뒤쪽(rear)에 요소를 추가하는 작업(push 메서드로 구현)**

**💬 dequeue: 큐의 앞쪽(front)에서 요소를 제거하는 작업(shift 메서드로 구현)**

📌 **[ 큐의 활용 분야 ]**

- 작업 대기열: 서버에 작업을 요청할때, 요청이 들어온 순서대로 작업을 처리

- 이벤트 처리: 사용자의 이벤트(ex) 키보드 입력, 마우스 움직임) 처리

📌 **[ 큐의 ADT ]**

: : 추상 자료형으로 인터페이스만 있고 실제로 구현되지 않은 자료형 (일종의 자료형의 설계도)

- isFull: 스택에 들어있는 데이터의 개수가 max size인지 확인하고, boolean 반환 (가득차면 true 그외는 false)

- isEmpty: 스택에 들어있는 데이터가 존재하는지 확인하고 boolean 반환 (하나라도 있으면 false 그외는 true)

  (front와 rear가 값이 같은지 확인한 후 큐에 원소가 없는데 pop하는 동작을 방지)

- push: 큐에 데이터 삽입

- pop: 큐에 처음으로 push한 데이터를 제거하고, 그 데이터를 반환

- front(큐의 앞): 큐에서 가장 처음에 pop한 위치를 기록 (초기 값: -1, 한 개 있으면 0)

- rear(큐의 뒤): 큐에서 최근에 push한 데이터의 위치를 기록 (초기 값: -1, 한 개 있으면 0)

💬 쉽게 생각해서 큐는 앞에서 데이터를 빼고 뒤에서 데이터를 추가한다고 생각하면 된다

📌 **[ 큐의 세부 동작 ]**

- push(3)을 진행했을때:

내부적으로 isFull을 호출하여 현재 큐가 가득 찼는지 확인 👉🏻 그렇지 않을 경우(= isFull이 false) rear를 1 증가시킴(rear가 -1에서 0이 됨) 👉🏻 현재 rear가 가르키는 위치 = 0, 0 위치에 3 push

- pop(3)을 진행했을때:

내부적으로 isEmpty를 호출하여 큐가 비었는지 확인 👉🏻 비어있지 않다면(= isEmpty가 false) front를 1 증가시킴(front가 -1에서 0이 됨) 👉🏻 rear와 front의 값이 같아짐 👉🏻 추후에 isEmpty 연산 시 큐가 빈 것으로 처리

💬 실제 배열의 데이터를 삭제하지 않고도 데이터를 삭제한 것처럼 관리 가능

- 큐가 가득 찼을때:

(위 진행한 결과에서 데이터 3개를 더 push했다고 가정)

마지막 push에서 실제 큐에 저장한 데이터는 3, @, @, @으로 4개지만, 실제 큐는 @, @, @로 3개이다.

(front는 0을 가르키고 있고, rear는 3을 가르키고 있음)

**실질적으로 front의 다음부터 rear까지를 큐가 관리하는 데이터로 생각해야하한다**

즉, 데이터의 공간은 4개인데 큐가 관리하는 데이터는 3개이므로 실질적인 메모리 공간을 낭비하는 상태!

💬 이를 개선하기 위해서는 한 방향(선형)으로 구현한 큐가 아닌 원형 큐를 사용해야한다.
