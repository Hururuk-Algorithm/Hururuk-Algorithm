시간 복잡도는 프로그램이 실행될 때 필요한 계산 횟수를 나타내는 방법

쉽게 말하면, 프로그램이 얼마나 빨리 실행되는지를 알려주는 도구

계산 횟수가 적을수록 프로그램이 더 빨리 실행됨

1차원 배열

연산 횟수가 가장 적은 경우 - 검색 시작 위치에 찾을 값이 바로 있는 경우

연산 횟수가 가장 많은 경우 - 아예 찾으려는 값이 없거나 가장 마지막에 위치하는 경우

알고리즘 수행 시간 측정 방법

절대 시간 측정하는 방법 - 말 그대로 시간을 측정 (프로그램 작성 - 실행 - 결과까지의 시간 측정)

그러나 코테에서는 잘 활용x

시간 복잡도 측정하는 방법 - 컴퓨터가 몇 번의 계산을 했는지 세는 것

(최선, 보통, 최악의 경우로 나눔)

코테에서 알고리즘의 성능을 측정할 때는 2가지가 중요함

1. 최악의 경우를 찾는 것
2. 알고리즘 성능은 정확한 연산 횟수가 아닌 추이 활용

빅오표기법

알고리즘의 성능을 표현할 때는 정확한 연산 횟수보다 입력 크기(n)에 따른 연산 횟수의 증가 추세가 증요한데 이를 표현하는 방법이 바로 점근적 표기법이며,

그 중에서도 최악의 경우를 나타내는 빅오 표기법이 많이 사용됨

= 입력 크기가 커질 때 프로그램의 실행 시간이 어떻게 변하는지 표현하는 방법

- O(1) - 상수 시간 - 입력 크기가 얼마나 크든 항상 같은 시간이 걸림
  ```jsx
  function printTenNumbers() {
      for (let i = 0; i < 10; i++) {
          console.log(i);
      }
  }

  10번 반복 → 실행 시간은 거의 일정함
  ```
- O(n) - 선형 시간 - 입력 크기가 2배가 되면, 실행 시간도 2배가 됨
  ```jsx
  function printNumbers(n) {
      for (let i = 0; i < n; i++) {
          console.log(i);
      }
  }

  n이 커질수록 실행 시간이 늘어남

  실행 횟수는 n번 → O(n) (선형 시간)
  ```
- O(n²) - 이차 시간 - 입력 크기가 2배가 되면, 실행 시간은 4배가 됨
  ```jsx
  function printPairs(n) {
      for (let i = 0; i < n; i++) {
          for (let j = 0; j < n; j++) {
              console.log(i, j);
          }
      }
  }

  바깥 반복문: n번

  안쪽 반복문: n번

  총 실행 횟수 = n × n = O(n²)
  ```
- O(log n) - 로그 시간 - 입력 크기가 2배가 되어도, 실행 시간은 조금만 증가
  ```jsx
  function binarySearch(arr, target) {
      let left = 0;
      let right = arr.length - 1;

      while (left <= right) {
          let mid = Math.floor((left + right) / 2);

          if (arr[mid] === target) return mid;
          if (arr[mid] < target) left = mid + 1;
          else right = mid - 1;
      }

      return -1;
  }

  입력 크기 2배 → 실행 횟수 거의 1 증가
  ```
- O(n²) - 지수 시간 - 입력 크기가 2배가 되면, 실행 시간은 2배씩 증가 (매우 비효율)
  ```jsx
  function fibonacci(n) {
      if (n <= 1) return n;
      return fibonacci(n - 1) + fibonacci(n - 2);
  }

  피보나치 수열처럼 모든 경우를 계산해야 하는 경우
  ```

n = 100일 때:

- O(1) = 1
- O(log n) ≈ 6.6
- O(n) = 100
- O(n log n) ≈ 660
- O(n²) = 10,000
- O(n³) = 1,000,000
- O(2ⁿ) = 너무 큰 숫자 (약 1.27 × 10³⁰)
- O(n!) = 상상할 수 없이 큰 숫자

우리가 빅오 표기법을 사용할 때는 연산량이 가장 크게 증가하는 부분만 남김

f(n)=3n² + 5n + 7 이라는 실행 횟수가 있다면 입력이 커질수록 3n² 가 압도적으로 커지므로 다른 항은 무시하고 O(n²) 로 표시한다.

코테에서는 제한 시간이 있어 시간 복잡도를 고려해야 함

입력 크기에 따라 어떤 알고리즘을 선택할지 결정해야

- **O(1)**: 상수 시간 - 입력 크기에 상관없이 항상 같은 시간 (최대 연산 횟수: 10)
- **O(2ⁿ)**: 지수 시간 - 매우 느림 (최대 연산 횟수: 20-25)
- **O(n³)**: 세제곱 시간 - 느림 (최대 연산 횟수: 200-300)
- **O(n²)**: 제곱 시간 - 중간 (최대 연산 횟수: 3,000-5,000)
- **O(NlogN)**: 선형-로그 시간 (최대 연산 횟수: 100만)
- **O(N)**: 선형 시간 - 빠름 (최대 연산 횟수: 1,000-2,000만)
- **O(logN)**: 로그 시간 - 매우 빠름 (최대 연산 횟수: 10억)

-

시간 복잡도 계산하기

1. 문제 정의하기 - 어떤 문제 푸는지 이해
2. 연산 횟수 측정하기 - 문제 풀 때 필요한 계산 횟수 세기
3. 시간 복잡도 분석하기 - 계산 횟수를 빅오 표기법으로 나타내기

ex. 별 찍기

문제 설명 - n을 입력받으면 n번재 줄까지 별을 찍는 문제

푸는 과정

1. 연산 횟수 구함

```jsx
N=3일 때:
*
**
***
총 별의 개수 = 1 + 2 + 3 = 6개

N=5일 때:
*
**
***
****
*****
총 별의 개수 = 1 + 2 + 3 + 4 + 5 = 15개
```

N(줄 수)이 커질수록 별의 총 개수는 더 빠르게 늘어남

별 찍기 문제에서 데이터(N)가 10배 커지면 작업량은 약 100배 커지며, 이는 N²에 비례하는 성장 패턴임
