📌 [ 시간 복잡도 ]
: 알고리즘의 성능을 나타내는 지표로, 입력 크기¹에 대한 연산 횟수의 상한을 의미

📌 [ 알고리즘 수행 시간 측정 방법 ]

- 절대 시간 측정: 프로그램을 실행하여 나올 때까지의 시간(실행 환경에 따라 달라지므로 잘 사용하지 않음)
- 시간 복잡도 측정: 시작한 순간부터 결괏값이 나올 때까지의 연산 횟수
  💬 어떠한 입력값이 들어올지 알 수 없기 때문에 최악의 경우를 기준으로 시간 복잡도를 분석
  💬 정확한 연산 횟수보다는 "연산 횟수의 추이"를 활용한 성능 측정 ( = 점근적² 표기법)

📌 [ 점근적 표기법 ]
: 입력 크기에 따른 연산 횟수의 추이를 활용하여 시간 복잡도를 표현하는 방법

📌 [ 빅오 표기법 ] ↔️ [ 빅오메가(Ω) 표기법: 하한선 ]
: 점근적 표기법에서 상한선을 활용한 방법³으로, 연산 횟수가 f(x)일때 함수의 최고차항을 남기고 계수를 지워 표현하는 방법
O(...)으로 표현한다 (상한과 하한이 같은 빅세타 표기법(Θ)도 있다)

(ex)

- 3x³ + 3x + 6 > O(x³) : 다항함수로 구성되어 최고차항만 남는다
- x + logx > O(x) : 증가폭이 더 낮은 로그함수는 사라지고 다항함수가 남는다
- 2ˣ + 10x⁵ + 5x² > O(2ˣ) : 빠르게 증가하는 지수함수만 남는다

= 지수함수 > 최고차항 > 로그함수

💬 빅오 표기법으로 구하고자 하는 것은 상한의 정확한 값이 아닌 연산 횟수의 추이를 파악하기 위함이기에 최고차항만 남기고 계수를 지우게 된다

📌 [ 시간 복잡도별 최대 연산 횟수 ]

| 시간 복잡도 | 최대 연산 횟수   | 대표적인 알고리즘 예시                   |
| ----------- | ---------------- | ---------------------------------------- |
| O(N!)       | 10               | 순열 생성 / 외판원 문제(완전 탐색)       |
| O(2^N)      | 20~25            | 부분 집합 생성 / 피보나치 수열(재귀)     |
| O(N^3)      | 200~300          | 3중 중첩 반복문 / 일부 행렬 연산         |
| O(N^2)      | 3,000~5,000      | 버블 정렬 / 삽입 정렬 / 선택 정렬        |
| O(NlogN)    | 100만            | 퀵 정렬 / 병합 정렬 / 힙 정렬            |
| O(N)        | 1,000~2,000만    | 배열 순회 / 선형 탐색                    |
| O(logN)     | 10억             | 이진 탐색 / 균형 이진 트리 탐색          |
| O(1)        | 고정된 연산 횟수 | 해시 테이블 조회 / 스택의 push, pop 연산 |

```
 1. 알고리즘이 처리해야 할 데이터양
 2. 어떤 함수의 증가하는 추세를 표현하는 표기법
 3. 알고리즘의 최악의 경우 또는 상한선의 성능을 나타낸다는 의미로 알고리즘이 특정 입력 크기에 대해 사용하는 자원의 최대량을 나타냄
    ( = 이 알고리즘은 최악의 경우에도 이 정도의 성능은 보장한다~ 이런 의미)
```
