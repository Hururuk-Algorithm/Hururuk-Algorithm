## 📌 배열

: 동일한 타입의 여러 데이터를 순차적으로 저장하는 자료구조

: 하나의 변수명으로 여러 값을 관리 / 각 데이터는 인덱스(0부터 시작하는 번호)를 통해 접근

## 📌 배열 선언하기

### 배열 생성자

- **new Array(n)**: n개의 빈 슬롯을 가진 배열이 생성(길이는 지정한 수(n)이지만, 실제 값이 할당되지 않은 상태)

```jsx
const arr1 = new Array(3); // [empty, empty, empty]

// map 함수와 함께 자주 쓰인다
const arr2 = [...new Array(3)].map((_, i) => i + 1); // [1, 2, 3]
```

💬 new Array(n)로 생성된 배열은 특별한 종류의 "희소 배열(sparse array)"로 배열은 길이는 n이지만, 실제로 값이 할당된 요소는 없는 상태

배열 메서드(map, filter, ･･･)는 빈 슬롯을 건너뛰기 때문에 이러한 배열에서는 스프레드 연산자를 사용하여 밀집배열¹로 변환해야함(스프레드 연산자를 사용하면 [undefined, undefined, ･･･] 형태로 변환)

- **Array.fill(n)**: 배열의 모든 요소를 지정한 값(value)으로 채워주는 메서드(기존 배열 변경)

```jsx
const arr = new Array(3).fill(7); // [7, 7, 7]
```

💬 fill() 메서드는 희소 배열의 빈 슬롯도 채워주기 때문에 new Array(n)으로 생성한 배열을 초기화할 때 유용

- **Array.from()**: 유사 배열 객체나 이터러블 객체로부터 새로운 배열 인스턴스를 생성하는 메서드

  (두 번째 인자로 매핑 함수를 제공할 수 있어 배열 생성과 동시에 값을 변환 가능)

```jsx
const arr = Array.from({ length: 3 }, (_, i) => i + 1); // [1, 2, 3]
```

## 📌 배열 연산의 시간 복잡도

: 배열은 임의 접근이라는 방법으로 배열의 모든 위치에 있는 데이터에 한 번에 접근 가능

: 따라서 기본적으로 데이터에 접근하기 위한 시간 복잡도는 O(1)

- **맨 뒤에 삽입할 경우**: 다른 데이터 위치에 영향을 주지 않고 바로 접근 가능(시간 복잡도 O(1))

- **맨 앞에 경우**: 기존 데이터를 추가한 만큼 미는 연산 필요 (시간 복잡도 O(데이터 개수))

- **중간에 삽입할 경우**: 현재 삽입한 데이터 뒤에 있는 데이터 개수만큼 미는 연산 필요 (시간 복잡도 O(밀어야하는 데이터 개수))

## 📌 자주 사용하는 배열 기법

### 배열 데이터 추가

- **push()**: 맨 끝에 데이터 추가(원본 배열 수정 / 반환값: 배열의 새 길이)

- **concat()**: 맨 끝에 데이터 추가(새로운 배열 생성 / 반환값: 합쳐진 새 배열)

- **스프레드 연산자**: 맨 앞이나 끝에 데이터 추가

- **unshift()**: 맨 앞에 데이터 추가(원본 배열 수정 / 반환값: 수정된 배열의 새 길이)

💬 맨 앞에 데이터를 추가하는 시간 복잡도는 O(n)이지만 배열 내 데이터가 적을 경우 자바스크립트 엔진이 최적화를 통해 더 적은 시간 복잡도로 처리

- **splice()**: 배열의 특정 위치에 요소 추가･삭제･교체(원본 배열 수정 / 반환값: 제거된 요소들의 배열)

```jsx
const arr = [1, 2, 3, 4, 5];
arr.splice(2, 0, 999); // [1, 2, 999, 3, 4, 5]

// splice(배열 내 시작 지점, 삭제할 데이터의 수, 추가할 데이터)
```

### 배열 데이터 삭제

- **pop()**: 맨 끝 요소를 제거(원본 배열 수정 / 반환값: 제거된 요소)

- **shift()**: 맨 앞 요소를 제거(원본 배열 수정 / 반환값: 제거된 요소)

💬 unshift()와 마찬가지로 배열 내 데이터가 적을 경우 자바스크립트 엔진이 최적화를 해줌

- **splice()**: 배열의 특정 위치에 요소 추가･삭제･교체(원본 배열 수정 / 반환값: 제거된 요소들의 배열)

```jsx
const arr = [1, 2, 3, 4, 5];
arr.splice(2, 2); // [3, 4] << 반환값 확인!

// splice(시작 지점, 삭제할 데이터의 수)
// 데이터 삭제를 진행할 경우 세번째 매개변수는 생략
```

### 고차 함수를 통한 특정 연산

: 고차 함수는 연산을 마친 배열(reduce 제외)을 반환(연산 대상을 직접 바꾸지 않는다)

- **map()**: 각 요소를 변환하여 새 배열 생성

- **filter()**: 조건을 만족하는 요소만 추출하여 새 배열 생성

- **reduce()**: 배열의 모든 요소를 순회하며 단일 값으로 축소(반환값: 누적 계산의 최종 결과값)

```
1. 희소배열의 반대말로 모든 인덱스 위치에 실제 값이 할당되어 있는 배열
```
