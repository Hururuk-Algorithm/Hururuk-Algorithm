📌 [ 빌트인 데이터 타입 ]

- 원시 타입
  ⤷ 숫자: 모든 숫자(자연수, 정수, 실수, 무한)에 대한 타입으로 number 타입으로 정의 / 연산자를 통해 계산이 가능하다
  💬 부동소수점: 컴퓨터가 숫자를 저장하는 방식으로, 일부 소수점 계산에서 정확하지 않은 결과가 나옴 (0.1 + 0.2는 0.3이 아닌 0.30000000000000004가 나옴)
  💬 앱실론(EPSILON): 컴퓨터가 구분할 수 있는 가장 작은 숫자 차이
  👉🏻 컴퓨터는 일부 소수를 정확하게 저장하지 못하기 때문에 Number.EPSILON을 통해 최소 차이를 구할 수있다.
  (정확한 비교는 절대값 차이가 EPSILON보다 작은지 확인)

        ```jsx
        function example(a, b) {
          return Math.abs(a - b) < Number.EPSILON;
        }

        console.log(example(0.1 + 0.2, 0.3)); // true
        ```

  ⤷ 문자열: 글자와 관련된 모든 자료는 string으로 정의 / 작은따옴표(''), 큰따옴표(""), 백틱(``)으로 감싸서 표현
  ⤷ boolean: true와 false 값으로만 이루어진 타입 / 일반적으로 논리 연산의 결과로 나오게 된다
  ⤷ BigInt: Number 타입으로 표현할 수 없는 큰 수를 다룰때 사용¹ / 숫자 뒤에 n을 붙이거나 BigInt()로 감싸 사용한다 / BigInt와 number연산을 시도하면 오류가 발생한다
  ⤷ undefined: 변수에 초기화되지 않았을 때 적용되는 타입
  ⤷ null: 의도적으로 비어있음을 표현하기 위한 값이자 타입²

- 참조 타입
  ⤷ object:
  - 배열: 대괄호를 통해 선언
  - 객체: 중괄호 안쪽에 키와 값을 적는 것으로 정의 / .과 ['key']의 형태로 접근 가능
    (값을 대입하여 요소 추가 가능 (ex) obj.age = 30 >> obj 객체에 age = 30 추가)
    ⤷ 함수: 일급 객체³이자 타입 function 키워드를 사용하거나 변수에 할당, 화살표 함수, 익명 함수로 선언이 가능함

📌 [ 데이터 타입의 동작 방식 ]

- 원시 타입: 메모리 할당 시 "값 자체"를 저장
  (변수의 값을 바꾸면 새로운 메모리에 할당하여 그 주소를 바라보게 변경, 기존 메모리와 상관x)

- 참조 타입: 메모리 할당 시 힙 메모리에 저장된 값을 가르키는 "메모리 주소"를 저장
  (요소의 값을 변경하더라도 새 메모리 주소 할당x)

📌 [ 자바스크립트의 문법 설탕(Syntactic Sugar) ]
: 코드를 더 읽기 쉽고 간결하게 작성할 수 있도록 해주는 언어적 기능

⤷ 구조 분해 할당: 배열이나 객체에서 요소를 분해하는 기능(배열은 [], 객체는 {} 사용)
⤷ swap: 구조 분해 할당을 이용하여 변수의 값을 교환하는 방법

````
[1]
temp = a;
a = b;
b = temp

            [2]
            let a = 5;
            let b = 10;
            [a,b] = [b,a]
            ```

⤷ 비구조화 할당: 함수에 객체를 인수로 전달할 때 필요한 것만 꺼내서 사용할 수 있는 문법 기능

            ```jsx
            function example({ occupation, name }) {
              console.log(`${occupation}${name}`);
            }

            const person = {
             name: '지민',
             age: 27,
             occupation: '개발자',
             city: '서울'
            };

            // 객체 전체를 전달하지만, 함수는 occupation과 name만 추출해서 사용
            example(person); // 개발자 지민
            ```

⤷ 스프레드 연산자: 배열이나 객체 여러 개를 하나로 합칠때 사용 (키가 같은 객체를 병합하는 경우 나중에 스프레드 연산자를 사용한 객체의 값이 저장된다)
⤷ 배열 내 같은 요소 제거: 스프레드 연산자 + Set 객체를 이용

```jsx
const num = [1, 2, 3, 3, 3, 2, 4, 5];
const newArr = [...new Set(num)];
console.log(newArr); // [1, 2, 3, 4, 5]
````

⤷ && 연산자: 앞 요소를 플래그로 사용하여 true일 경우 뒤 요소 반환
⤷ || 연산자: 앞 요소를 플래그로 사용하여 false일 경우 뒤 요소 반환

📌 [ 숫자 타입 비트 연산(이진수로 변경하고 자리별로 계산) ] / (a = 13 / b = 4)일때

💬 [ 2진수 > 10진수 변환 ]

- 1101 (오른쪽부터 변환)
  : 1 × 2^0 👉🏻 1 × 1 = 1
  0 × 2^1 👉🏻 0 × 2 = 0
  1 × 2^2 👉🏻 1 × 4 = 4
  1 × 2^3 👉🏻 1 × 8 = 8
  1 + 0 + 4 + 8 =
  > > 13 변환

💬 [ 2진수 변환 ]

- 13
  : 13 / 2 = 6 ... 1
  6 / 2 = 3 ... 0
  3 / 2 = 1 ... 1
  1 / 2 = 0 ... 1
  > > 1101 변환 (아래에서 위로)
- 4
  : 4 / 2 = 2 ... 0
  2 / 2 = 1 ... 0
  1 / 2 = 0 ... 1
  > > 100 변환

💬 [ 비트 AND 연산(&) ] : 두 비트 모두 1일때만 결과 비트가 1이 된다
1101 (13)
0100 (4)

---

0100 (4) (a & b) // 4 출력

💬 [ 비트 OR 연산(|) ] : 두 비트 중 하나라도 1이면 결과 비트가 1이 된다
1101 (13)
0100 (4)

---

1101 (13) (a | b) // 13 출력

💬 [ 비트 XOR 연산(^) ] : 두 비트가 서로 다를 때만 1을 반환하고, 같을 때는 0을 반환
1101 (13)
0100 (4)

---

1001 (9) (a ^ b) // 9 출력

💬 [ 비트 NOT 연산(~) ] : 각 비트를 반전(0은 1로, 1은 0으로 변환)
공식: ~n = -(n+1)
-(13+1)
(~a) // -14 출력

💬 [ 비트 Left Shift 연산(<<) ] : 해당 숫자의 모든 비트를 왼쪽으로 지정된 수 만큼 이동
공식: n << m = n x 2^m
13 x 2^2
(a << 2) // 52 출력

💬 [ 비트 Right Shift 연산(>>) ] : 해당 숫자의 모든 비트를 오른쪽으로 지정된 수 만큼 이동
공식: n >> m = floor(n ÷ 2^m)
floor(13 ÷ 2^1) 👉🏻 floor(6.5) 👉🏻 소수점 버리기
(a >> 1) // 6 출력

```
📋
1. 숫자 타입은 큰 수를 다룰 경우 연산 결과에 문제가 생길 수 있어 대략적으로 16자리수를 넘어가는 정수에 사용한다
2. 0은 휴지걸이에 빈 휴지심만 있는 형태 / null은 휴지걸이만 있는 상태 / undefined는 아무것도 존재하지 않는 상태
3. 변수에 할당 / 함수의 인자로 전달 / 함수에서 반환할 수 있는 객체를 의미
```
